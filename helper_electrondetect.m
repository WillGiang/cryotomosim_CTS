function [detect,rad] = helper_electrondetect(tilt,param)
%detect = helper_electrondetect(tilt,param)
%simulates electron detection by camera of a CTF-convolved tiltseries. simulates electon transmission and
%interaction with poisson sampling, after estimating electrons lost by inelastic scattering.
%
%tilt - tiltseries to simulate detection through
%param - parameter structure generated by cts_param, see that function for arguments and help
%
%detect - output of simulated electron detection by counting mode camera
arguments
    tilt
    param struct
end
if param.dose<=0, detect=tilt; return; end %if dose 0, skip detection and return perfect detection/original
tiltangs = param.tilt; %unfortunately similar name to tilt 

DQE = .84*1; % gatan camera lists 84% maximum detection, so that'll work for now
%4 is arbitrary scalar to make contrast look 'normal' with the CTF modulation
%DQE should not be angle dependent, but maybe easier to  implement if merged with CTF?

switch param.tiltscheme %organize tilt ordering, sort according to split if not symmetric
    case 'symmetric'
        [~,ix] = sort(abs(tiltangs)); 
    otherwise %find and sort the data from the split between tilt directions
        mdist = max(abs(tiltangs-(param.tiltscheme))); %max dist from start angle where phase will switch
        metric = abs(tiltangs-param.tiltscheme)+mdist.*(tiltangs<param.tiltscheme); %calculate sorting metric
        [~,ix] = sort(metric);
end
tiltangs = tiltangs(ix); tilt = tilt(:,:,ix); %sort tilt angles and tilts
ixr(ix) = 1:numel(ix); %generate reverse sorting index

%dose weighting/distribution
dose = param.dose;%.*param.pix^2; %convert dose in e/A^2 to e/pixel
if numel(param.dose)==1
    dose = dose/size(tilt,3); %single dose distributed across tilts evenly
else
    dose = dose(ix); %for weighting just sort the weights to the tilts
end

thick = param.size(3)*param.pix; %compute thickness from depth of original model
IMFP = 3800; %inelastic mean free path, average distance before inelastic electron scatter (for water/ice)
%IMFP estimated to be 350nm for water ice, is probabaly somewhat different for vitreous (higher)
%electronpath = thick*(1+abs(tand(tiltangs))); %compute the path length of electrons through ice
electronpath = thick*cosd(tiltangs).^-1; %corrected trig, very slightly better appearance
thickscatter = exp(-(electronpath*param.scatter)/IMFP); %compute electrons not inelastically/lossly scattered
%change IMFP to instead be per pixel, so more electrons are lost at high density AND thickness?

radscale = .04*param.raddamage;%/param.pix^2; %damage scaling calculation to revert scaling by pixel size

dw = thickscatter.*dose*DQE;
accum = 0; %initialize accumulated dose of irradiation to 0
detect = tilt.*0; %pre-initialize output array for speed during the loop
rad = tilt*0; testout = rad;
%2d blur each angle outside loop for speed
blurmap = imgaussfilt( max(tilt,[],'all')-tilt );
for i=1:size(tilt,3)
    
    accum = accum+dw(i); %add to accumulated dose delivered
    %first tilt should be irradiated, it does happen instantly after all
    
    %blur map for radiation - should the blur be in 3d? would add some useful smearing of data
    %use the pre-CTF tilt for the rad map to avoid CTF impacts?
    %radmap = imgaussfilt(rescale(-tilt(:,:,i)));
    radmap = rescale(blurmap(:,:,i),0,sqrt(param.pix))*1; %a bit hamfisted rescaling
    
    %increase magnitude of noise near gradients, so borders get more noise
    %appears to work, but adds noise rather than truly blurring the image
    addrad = randn(size(radmap))*accum*radscale.*(radmap+1);%.*(1+rescale(imgradient(tilt(:,:,i)),0,param.pix));
    
    sigma = (accum)/100;
    proj = imgaussfilt(tilt(:,:,i),sigma,'FilterSize',5); 
    testout(:,:,i) = proj;
    
    irad = proj+addrad; %radiation as 0-center noise
    %need to do some procedure to mask/weight the noise near density rather than globally
    
    
    detect(:,:,i) = poissrnd(irad*dw(i),size(irad));
    
    rad(:,:,i) = proj; %store radiation maps for review
end
rad = rad(:,:,ixr);
detect = detect(:,:,ixr); %reverse the sort so the output tiltseries is a continuous rotation
end